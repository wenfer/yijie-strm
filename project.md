## 🤖 Assistant

没问题，这是一份为您量身定制的**《115 网盘 Python 直连播放网关 (115-Strm-Gateway) 项目技术文档》**。

您可以将其作为开发大纲，逐项攻克。

---

# 项目名称：115-Strm-Gateway

## 1. 项目概述
本项目旨在构建一个基于 Python 的轻量级中间件，连接 115 网盘与本地媒体服务器（Emby/Plex）。
**核心原理：** 通过扫描网盘目录生成指向本服务的 `.strm` 文件，拦截播放请求后，实时获取网盘直链并进行 302 重定向，从而实现本地服务器“零流量”播放高清视频。

## 2. 技术栈选型

| 模块 | 技术选型 | 理由 |
| :--- | :--- | :--- |
| **语言** | Python 3.9+ | 开发效率高，网络库丰富，生态完善 |
| **Web 框架** | **FastAPI** | 高性能异步框架，原生支持 OpenAPI 文档，适合高并发 I/O |
| **HTTP 客户端** | **Httpx** (异步) / Requests | 处理与 115 API 的通信，推荐使用异步库提升并发扫描速度 |
| **加密/算法** | PyCryptodome / hashlib | 处理 115 API 登录签名和数据加解密 |
| **数据库** | SQLite / Dictionary (内存) | 缓存文件元数据和目录结构，轻量级即可 |
| **任务调度** | APScheduler | 定时执行扫库、Cookie保活任务 |
| **二维码** | qrcode | 终端生成登录二维码 |

---

## 3. 功能清单与实现逻辑

### 模块一：115 认证中心 (Auth Module)
负责处理登录、Cookie 管理与保活。

*   **[1.1] 扫码登录**
    *   **实现：** 调用 115 接口获取二维码 Token -> 使用 `qrcode` 库在终端/网页打印二维码 -> 轮询接口检测扫码状态 -> 获取 Cookie (UID, CID, SEID)。
    *   **难点：** 115 的 App 扫码接口有时效性，需处理过期重试逻辑。
*   **[1.2] Cookie 持久化**
    *   **实现：** 将获取的 Cookie 存入本地文件（如 `cookies.json`）或 SQLite。启动时自动读取。
*   **[1.3] Cookie 保活与检测**
    *   **实现：** 设定定时任务（如每 12 小时），调用一个轻量级接口（如获取用户信息），若返回 401/失效，则通过钉钉/Telegram/日志通知用户重新扫码。

### 模块二：网盘扫描与 STRM 生成 (Scanner Module)
负责将云端文件映射为本地 STRM 文件。

*   **[2.1] 文件树遍历**
    *   **实现：** 递归调用 115 的 `files` 接口。
    *   **优化：** 使用 `cid` (Category ID) 进行分页查询。支持设置“仅扫描特定文件夹”配置项。
*   **[2.2] 增量/全量同步**
    *   **实现：**
        *   **全量：** 清空本地目录重新生成。
        *   **增量（进阶）：** 记录上次扫描时间，或对比本地数据库与云端文件列表的差异。
*   **[2.3] STRM 文件生成**
    *   **实现：**
        *   在本地创建与网盘层级一致的文件夹。
        *   针对视频文件（mkv, mp4等），创建同名 `.strm` 文件。
        *   **关键内容写入：** `http://{本机IP}:{端口}/play/{pickcode}/{filename}`
        *   *注：传入 `pickcode` 是因为它是 115 获取下载链的唯一凭证，传入 `filename` 是为了让播放器识别文件名（部分播放器依赖 URL 后缀）。*

### 模块三：播放网关 (Gateway Module)
核心 Web 服务，拦截请求并重定向。

*   **[3.1] 播放接口 (`/play/{pickcode}/{filename}`)**
    *   **实现：** 这是一个 GET 路由。
    *   **入参：** `pickcode` (文件提取码), `Request Headers` (尤其是 User-Agent)。
*   **[3.2] 直链获取 (Get Download URL)**
    *   **实现：**
        *   接收到请求后，使用存储的 Cookie 和 `pickcode` 调用 115 的 `files/download` 接口。
        *   **加密签名：** 115 接口通常涉及 Params 的加密和 Signature 生成（这是最大的难点，需参考开源实现）。
        *   解析返回的 JSON，提取 `file_url`。
*   **[3.3] 302 重定向**
    *   **实现：** 返回 HTTP 302 状态码，Header `Location` 设为上一步提取的直链。
*   **[3.4] User-Agent 透传**
    *   **实现：** 115 对 UA 有校验。建议在请求直链时，将请求头的 User-Agent 设置为浏览器标识（如 `Mozilla/5.0...`），或者尝试透传播放器的 UA（如果 115 允许）。**推荐方案：** 硬编码一个通用的浏览器 UA 给 115 接口。

### 模块四：系统配置与管理 (Config Module)

*   **[4.1] 配置文件**
    *   `config.yaml`：包含 115 账号信息（可选）、本地 STRM 输出路径、服务端口、日志级别、扫描黑名单（如忽略 `.iso`）。
*   **[4.2] 日志系统**
    *   记录扫描进度、播放请求日志（方便排查哪个文件播放失败）、API 错误日志。

---

## 4. 关键 API 接口定义 (参考)

在编写代码时，你需要封装以下 Python 函数（伪代码）：

```python
class P115Client:
    def login_with_qrcode(self):
        """处理扫码流程"""
        pass
        
    def get_files(self, cid="0", page=1):
        """获取指定目录下的文件列表"""
        # API: https://webapi.115.com/files
        pass
        
    def get_download_url(self, pickcode, user_agent):
        """获取真实下载直链"""
        # API: https://proapi.115.com/app/chrome/downurl (示例，接口常变)
        # 需处理加密解密
        pass
```

## 5. 开发阶段与里程碑

### 阶段一：API 攻坚 (预计 1-2 天)
*   **目标：** 编写一个 `test_115.py` 脚本，能成功扫码登录，并打印出根目录文件列表，且能拿到某个视频的下载链接（在浏览器能打开）。
*   **资源：** 
    *   GitHub 搜索关键词：`115 webapi reversed`, `fake115 python`。
    *   重点参考项目：[deadblue/elevengo](https://github.com/deadblue/elevengo) (Go语言，逻辑非常清晰，可转译 Python)。

### 阶段二：Web 服务搭建 (预计 1 天)
*   **目标：** 使用 FastAPI 跑起服务，定义 `/play` 接口。
*   **测试：** 手动构造一个 STRM 文件指向本机接口，用 VLC 播放器打开 STRM 文件，验证是否能跳转播放 115 视频。

### 阶段三：扫描器实现 (预计 1-2 天)
*   **目标：** 实现递归扫描和 STRM 批量生成。
*   **测试：** 运行脚本，本地生成几百个 STRM 文件，层级结构正确。

### 阶段四：集成与优化 (预计 1 天)
*   **目标：** 对接 Emby，处理异常（如 Token 过期、网络超时）。添加 Dockerfile 方便部署。

---

## 6. 避坑指南 (开发者必读)

1.  **加密算法：** 115 的 PC 端 Web API 使用了一套基于 AES 和 RSA 的加密握手，非常复杂。
    *   *建议策略：* 不要死磕 Web 端接口。尝试模拟 **115 iOS/Android APP** 的接口，或者模拟 **115 浏览器插件** 的接口（相对简单）。如果找不到现成的 Python 库，可以考虑直接调用 `g115` 或 `alist` 的二进制文件作为子进程来获取链接（虽然不优雅，但极快解决问题）。
2.  **User-Agent (UA)：** 某些时候 115 可能会限制非浏览器 UA 的下载请求。如果 Emby 播放失败，尝试在获取直链时，强制指定 UA 为 Chrome 的 UA。
3.  **并发限制：** 扫描文件时，并发数不要超过 5-10，否则可能触发 API 临时封禁（表现为暂时无法列出文件）。
4.  **Pickcode vs File_id：** 115 有两个核心 ID。`file_id` 用于浏览目录，`pickcode` (提取码) 用于下载。生成 STRM URL 时，一定要把 `pickcode` 带上，它是换取直链的钥匙。

这份文档是否符合您的预期？如果需要，我可以为您提供 **阶段一：模拟登录与获取文件列表** 的具体 Python 代码 Demo。
